# -*- coding: utf-8 -*-
"""ADO 02 - Calculo Numerico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_HHxabiIUeD3dePjsGYyEgrS3drO-GdU

#### 1. (Método de Newton-Raphson) A velocidade v do para-quedista em queda livre é dada por $v=\frac{gm}{c}(1-\mathrm{e}^{-\frac{c}{mt}})$, onde $g = 9.8m/s^2$. Para um paraquedista com um coeficiente de arrasto $c = 15kg/s$, calcule a massa para que a velocidade seja $v = 35m/s$ em $t = 9s$. Considere o erro de $ε = 0.1\% $.
"""

import numpy as np

g = 9.8
t = 9
c = 15

def funcao(m):
  return ((g * m) / c) * (1 - np.exp( -(c / m) * t ))

def funcaoAdaptada(m):
  return 35 - (((g * m) / c) * (1 - np.exp( -(c / m) * t )) )

def derivadaDaFuncao(m):
  return -((g * (1 - np.exp(-((t*c)/m)) - ((np.exp(-((t*c)/m)*t*c)/m)) ) ) / c)

def newtonRaphson(x):
  contador = 0
  h = funcaoAdaptada(x) / derivadaDaFuncao(x)

  while abs(h) > 0.001:
    h = funcaoAdaptada(x) / derivadaDaFuncao(x)
    x = x-h
    contador += 1

  print("")
  print(f"O valor da massa do paraquedista é : {round(x, 6)}")
  print(f"A massa foi achada em {round(contador, 6)} iterações")
  print("")

  return x


x0 = 70
massa = newtonRaphson(x0)
print(f"Com a massa {round(massa, 6)} é possível achar a velocidade {round(funcao(massa),6)}")

"""#### 2. (Método das Secantes) Um tanque esférico foi projetado para armazenar água para um vilarejo. O volume de líquido que ele armazena pode ser calculado por $V = 2πh^2(3R − h)^3$, onde V é o volume, em $m^3$, h é a profundidade da água no tanque, em m, R é o raio do tanque, em m. Se R = 3m, até que profundidade o tanque deve estar cheio para que ele armazene 30 m3.



"""

import numpy as np

def funcao(h):
  f = (6 * np.pi * (h**2)) - ((-2*np.pi*(h**3))/3) - 30
  return f

def metodoSecante(xa, xb, e):
  print(f"Xa: {xa}; Xb: {xb}; E: {e};")
  while abs((xb-xa)/xa) > e:
    xk = (xb * funcao(xa) - xa * funcao(xb)) / (funcao(xa) - funcao(xb))
    xa = xb
    xb = xk
  return xb


h = metodoSecante(1, 1.4, 10**3)
print(f"A raiz achada pelo método da secante foi: {round(h,6)}")
print(f"Aplicando na função: {round((6 * np.pi * (h**2)) - ((-2*np.pi*(h**3))/3), 6)}")

"""#### 3. (Método da Bissecção) Determine todas as raízes da equação $x^3 + 12x^2 − 100x − 6 = 0$. Considerar o erro $ε = 0.1%$. Usar os intervalos [−10, 8], [−2, 0] e [8, 10] para determinar cada raiz"""

import numpy as np

f = lambda x: x**3 + 12*x**2 - 100 * x - 6

def bisseccao(f, a, b, e, xn):
  if f(a) * f(b) > 0:
    print(f"Iteração nº {xn}: Não pode-se afirmar se existe raiz ou não neste intervalo")
    return

  xn += 1

  m = (a+b)/2
  m = round(m, 6)

  if np.abs(f(m)) < e:
    print(f"Iteração nº {xn}: Existe raiz no intervalo entre {round(a, 6)} e {round(b, 6)}, e ela é {round(m, 6)}")
    return m

  elif np.sign(f(a)) == np.sign(f(m)):
    return bisseccao(f, m, b, e, xn)

  elif np.sign(f(b)) == np.sign(f(m)):
    return bisseccao(f, a, m, e, xn)


def numero_de_iteracoes(a, b, e):
  return np.ceil( (np.log(b-a) - np.log(e)) / np.log(2) )


print("Intervalo de -10 a 8")
bisseccao(f, -10, 8, 0.001, 0)
print("")

print("Intervalo de -2 a 0")
bisseccao(f, -2, 0, 0.001, 0)
print("")

print("Intervalo de 8 a 10")
bisseccao(f, 8, 10, 0.001, 0)